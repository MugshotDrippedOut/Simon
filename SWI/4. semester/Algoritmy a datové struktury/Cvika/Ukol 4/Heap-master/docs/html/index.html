<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Heap: HALDA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Heap
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Template of student task</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">HALDA </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> Naprogramujte datovou strukturu Halda (Min-Heap).</p>
<p>Programujeme <b>Min-Heap</b> tudíž první prvek je vždy nejmenší z celé datové struktury. Pro Min-Heap platí jednoduché pravidlo, řekněme, že máme index 'Q' pro prvky na indexu '<b>Q * 2</b>' a '<b>Q * 2 + 1</b>' (následníci) vždy platí, že jsou větší než prvek na samotném indexu '<b>Q</b>'(předchůdce)</p>
<p>Konečná halda může vypadat následovně: </p><hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Prvky   </th><th class="markdownTableHeadNone">5   </th><th class="markdownTableHeadNone">6   </th><th class="markdownTableHeadNone">20   </th><th class="markdownTableHeadNone">25   </th><th class="markdownTableHeadNone">7   </th><th class="markdownTableHeadNone">21   </th><th class="markdownTableHeadNone">22   </th><th class="markdownTableHeadNone">26   </th><th class="markdownTableHeadNone">27    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Index v poli   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">8   </td></tr>
</table>
<hr  />
<p>Jelikož začínáme na nultém prvku, tak pokud si chceme toto pravidlo zkontrolovat, musíme k indexu připočíst 1 (V kódu však nemusíme).</p>
<p>Např. prvek na indexu 3 (20) musí být menší jak prvky na indexu 6 (21) a 7 (22).</p>
<p><b>Příklad vkládání do haldy:</b></p>
<p><img src="heap_insert.gif" alt="" class="inline" title="Heap Insert"/></p>
<p><b>Příklad mazání nejmenšího prvku v haldě:</b></p>
<p><img src="heap_deletemin.gif" alt="" class="inline" title="Heap DeleteMin"/></p>
<p>Ve svém programu můžete využít funkci Heap_Print, která vypíše samotný prvek s jeho indexem, tak i jeho potomky.</p>
<ul>
<li>Program musí být univerzální a být schopen pojmout libovolné množství záznamů.</li>
<li>Počáteční maximální počet položek v haldě je 4</li>
<li>Pokud halda překročí maximální počet položek, zdvojnásobíme její velikost</li>
</ul>
<p><b>Poznámky:</b></p>
<p>Nezapomeňte na dynamicky alokovanou paměť, pro kterou poslouží knihovna 'mymalloc.h'</p>
<p>Pro porovnávání dvou prvků využijte funkce 'Data_Cmp' z knihovny '<a class="el" href="data_8h.html" title="Declaration of the data module.">data.h</a>'</p>
<p>Následuje krátký popis funkcí, které potřebujeme ke správné funkci naší haldy (podrobnější popis můžete najít v hlavičkovém souboru '<a class="el" href="heap_8h.html" title="Header file of heap module.">heap.h</a>').</p>
<h2><a class="anchor" id="autotoc_md1"></a>
V jazyce C implementujte následující funkce:</h2>
<p><b>Heap_Init</b> - Inicializuje haldu</p>
<p><b>Heap_Insert</b> - Vloží prvek na poslední místo a pokud jeho předchůdce je větší, prohodíme tyto 2 prvky a tento krok provádíme, dokud náš prvek není větší než předchůdce a nebo se náš prvek nedostane na první pozici</p>
<p><b>Heap_Destruct</b> - Uvolní naalokovanou paměť. Nastaví jednotlivé položky haldy na nulové hodnoty.</p>
<p><b>Heap_FindMin</b> - Navrátí nejmenší prvek, který se v datové struktuře nachází</p>
<p><b>Heap_DeleteMin</b> - Odebere nejmenší prvek z haldy. Prvek z poslední pozice přesuneme na první pozici avšak místo s předchůdci ho porovnáme s jeho následovníky, a prohazujeme opět dokud následnovníci nebudou větší než náš prvek</p>
<p><b>Heap_Empty</b> - Tato funkce nám sdělí jestli je naše halda prázdná či obsahuje nějaký prvek</p>
<p><b>Heap_Count</b> - Funkce, která nám sdělí kolik prvků se právě nachází v haldě.</p>
<p><b>Heap_Process</b> - Iteruje haldou a s každým prvkem provede definovanou opraci.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
HEAP</h1>
<p>The task is Min-Heap -&gt; The first element (index 0) is always the smallest from the whole data structure. Min-Heap has a simple rule, lets say we have index 'Q', the element on the index '<b>Q * 2</b>' and '<b>Q * 2 + 1</b>' (childrens) are <b>always bigger</b> that the item itself on position '<b>Q</b>' (father).</p>
<p>The final Min-Heap could look like this :</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Items   </th><th class="markdownTableHeadNone">5   </th><th class="markdownTableHeadNone">6   </th><th class="markdownTableHeadNone">20   </th><th class="markdownTableHeadNone">25   </th><th class="markdownTableHeadNone">7   </th><th class="markdownTableHeadNone">21   </th><th class="markdownTableHeadNone">22   </th><th class="markdownTableHeadNone">26   </th><th class="markdownTableHeadNone">27    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Index in array   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">8   </td></tr>
</table>
<hr  />
<p>Since we're starting at index 0, for easier check let's say that index 0 is index 1 just for now, the item on index 3 (20) has to be always smaller that the items on the index 6 (21) and 7 (22).</p>
<p><b>Example of inserting item in heap:</b></p>
<p><img src="heap_insert.gif" alt="" class="inline" title="Heap Insert"/></p>
<p><b>Example of deleting an item with the lowest value:</b></p>
<p><img src="heap_deletemin.gif" alt="" class="inline" title="Heap DeleteMin"/></p>
<p>In your program you can easily print your heap using Heap_Print, which will print the item itself and his childrens.</p>
<ul>
<li>Program has to be universal and be able to store any amount of items</li>
<li>The starting maximum number of items in heap is 4</li>
<li>If the heap reaches its maximum number of items, double its size</li>
</ul>
<p><b>Notes:</b></p>
<p>For allocating memory don't forget to use the functions from library 'mymalloc.h'</p>
<p>For comparing items use the function 'Data_Cmp' from library '<a class="el" href="data_8h.html" title="Declaration of the data module.">data.h</a>'</p>
<p>A brief description of functions, that we need for our heap to work properly (More detailed description can be found in header file '<a class="el" href="heap_8h.html" title="Header file of heap module.">heap.h</a>').</p>
<h3><a class="anchor" id="autotoc_md3"></a>
In C language implement those functions:</h3>
<p><b>Heap_Init</b> - Initializes the heap</p>
<p><b>Heap_Insert</b> - Inserts the item at the end of heap and if the father item is bigger, we switch those items, this happens until our item isn't bigger than his father item or the item get's to the first position.</p>
<p><b>Heap_Destruct</b> - Releases the allocated memory. Sets each heap item to zero.</p>
<p><b>Heap_FindMin</b> - Returns the smallest item in the heap.</p>
<p><b>Heap_DeleteMin</b> - Deletes and returns the smallest item in heap. The item that is at the end of the heap we move to the first place, then we compare it with his childrens and swap them until the rules are met.</p>
<p><b>Heap_Empty</b> - Returns if our heap is empty or if there's an item.</p>
<p><b>Heap_Count</b> - Returns the amount of items stored in heap.</p>
<p><b>Heap_Process</b> - Iterates through the heap and performs defined operation with each node. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
